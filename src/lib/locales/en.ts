export const en = {
  sidebar: {
    title: 'PathFinder',
    theory: 'Theory',
    algorithms: 'Algorithms',
    challenges: 'Challenges',
    bigO: 'Big O Notation',
  },
  workspace: {
    selectAlgorithm: 'Select an algorithm to see the details.',
  },
  bigO: {
    title: 'Understanding Big O Notation',
    description: 'Big O notation is how programmers talk about the efficiency of algorithms. It measures the worst-case time or space an algorithm takes to complete relative to the size of its input (n). In simpler terms, it describes how the performance of an algorithm scales as the input data grows.',
    importanceTitle: 'Why is it Important?',
    importanceDescription: 'Knowing the Big O helps you choose the right algorithm for the job. An algorithm that works fine for a small input might become unusably slow with a large input. Understanding Big O helps you avoid performance bottlenecks and write faster, more scalable code.',
    complexities: {
      title: 'Common Complexities',
      exampleLabel: 'Example:',
      constant: {
        name: 'O(1) â€” Constant Time',
        description: 'The algorithm takes the same amount of time, regardless of the input size. This is the ideal.',
        example: 'Accessing an element in an array by its index (e.g., `my_array[5]`).',
      },
      logarithmic: {
        name: 'O(log n) â€” Logarithmic Time',
        description: 'The time it takes increases with the input size, but it does so very slowly. This happens when the problem size is halved at each step.',
        example: 'Binary Search in a sorted array.',
      },
      linear: {
        name: 'O(n) â€” Linear Time',
        description: 'The runtime is directly proportional to the input size (n). If you double the input, the runtime roughly doubles.',
        example: 'Iterating through all elements in a list or array.',
      },
      loglinear: {
        name: 'O(n log n) â€” Log-Linear Time',
        description: 'This is a common complexity for efficient sorting algorithms. It\'s slightly slower than linear but still very performant for large datasets.',
        example: 'Efficient sorting algorithms like Merge Sort or Quick Sort.',
      },
      quadratic: {
        name: 'O(nÂ²) â€” Quadratic Time',
        description: 'The runtime is proportional to the square of the input size. This becomes slow very quickly as n grows.',
        example: 'Nested loops, where you compare every element of a list to every other element (e.g., finding all pairs in a list).',
      },
      exponential: {
        name: 'O(2^n) â€” Exponential Time',
        description: 'The runtime doubles for each new element in the input set. These algorithms are extremely slow and only practical for very small input sizes.',
        example: 'Solving problems with brute-force recursive solutions, like finding all subsets of a set (backtracking).',
      },
    },
  },
  algorithmDetails: {
    whenToUse: 'When to Use It',
    keywords: 'Keywords & Signals',
    typicalProblem: 'Typical Problem',
    codeTemplates: 'Code Templates',
    codeTemplatesDescription: 'Basic templates in Python and JavaScript to get you started.',
    bigO: 'Big O Notation',
    bigODescription: 'The performance characteristics of this algorithm.',
    timeComplexity: 'Time Complexity',
    spaceComplexity: 'Space Complexity',
    best: 'Best',
    average: 'Average',
    worst: 'Worst',
    practiceThisAlgorithm: 'Practice this algorithm',
  },
  codeBlock: {
    copied: 'Copied to clipboard!',
    copiedSuccess: 'The {language} code has been copied.',
    copyCode: 'Copy code',
  },
  challengeLabels: {
    title: 'Algorithm Challenges',
    learningTip: 'To learn even better, besides practicing with flashcard challenges, it\'s good to write down the exercises, the correct algorithm, and build the solution in a notebook to learn and retain the knowledge.',
    nextChallenge: 'Next Challenge',
    problem: 'Problem',
    whichAlgorithm: 'Which algorithm is most suitable?',
    checkAnswer: 'Check Answer',
    selectOptionTitle: 'Select an option',
    selectOptionDesc: 'You need to choose an algorithm before checking the answer.',
    correctTitle: 'Correct!',
    correctDesc: 'Great job!',
    incorrectTitle: 'Incorrect!',
    incorrectDesc: 'Try again. Hint: Think about the keywords in the problem.',
    correctExclamation: 'ðŸŽ‰ Correct! ðŸŽ‰',
    correctSolution: 'The correct algorithm is {solution}. Good job!',
    incorrectExclamation: 'Almost there!',
    incorrectSolution: "The correct answer is {solution}. Don't worry, keep trying!",
    hint: 'Hint',
    tryAgain: 'Try Again',
    loading: 'Loading challenges...',
    showingChallengesFor: 'Showing challenges for: {algorithm}',
    showingChallengesForDescription: 'Practice with problems specifically for this algorithm to master it.',
    clearFilter: 'Clear filter and see all challenges',
    noChallengesFound: 'No challenges found for this filter.',
  },
  algorithms: {
    'sliding-window': {
        name: 'Sliding Window',
        whenToUse: 'The problem involves a linear data structure (array, list, string) and asks to find a contiguous sub-section (subarray or substring) that is optimal in some way (longest, shortest, max sum, etc.).',
        keywords: ['contiguous subarray', 'substring', 'longest/shortest length', 'max/min sum', 'contains k distinct elements'],
        example: 'Given an array of integers, find the maximum sum of any contiguous subarray of size k.'
    },
    'two-pointers': {
        name: 'Two Pointers',
        whenToUse: 'The problem involves a sorted array (or one that can be sorted) and seeks a pair or triplet of elements that satisfy a condition. Often, one pointer starts at the beginning and one at the end, moving towards each other.',
        keywords: ['sorted array', 'find a pair/triplet', 'target sum', 'remove duplicates', 'palindrome'],
        example: 'In a sorted array, find two numbers that sum up to a target value X.'
    },
    'backtracking': {
        name: 'Backtracking',
        whenToUse: 'The problem asks to find all possible solutions or a single solution that satisfies complex constraints by building the answer step-by-step. If a choice leads to a dead end, you "go back" (backtrack) and try another. It\'s a structured Depth-First Search (DFS).',
        keywords: ['find all combinations', 'permutations', 'subsets', 'possible paths', 'puzzle', 'Sudoku', 'maze'],
        example: 'Given a set of numbers, find all unique subsets.'
    },
    'dynamic-programming': {
        name: 'Dynamic Programming (DP)',
        whenToUse: "It's an optimization problem (find the max/min) or a counting problem (count the number of ways) where the solution to a larger problem can be built from the solutions of smaller, overlapping subproblems.",
        keywords: ['number of ways to...', 'min/max cost path', 'max/min value obtainable', 'maximum profit'],
        example: 'Knapsack Problem: Given items with weights and values, what is the maximum value that can fit in a knapsack of capacity W?'
    },
    'bfs': {
        name: 'Breadth-First Search (BFS)',
        whenToUse: 'The problem involves graphs or matrices and asks for the shortest path from one point to another, assuming all steps have the same cost. BFS explores the neighborhood in "layers".',
        keywords: ['shortest path', 'fewest number of steps', 'levels of a tree', 'unweighted graph', 'maze'],
        example: 'In a matrix with walls, find the shortest number of steps to get from the top-left to the bottom-right corner.'
    },
    'dfs': {
        name: 'Depth-First Search (DFS)',
        whenToUse: 'The problem involves graphs or matrices and asks to explore paths to their end, check if a path exists, or find connected components. It does not guarantee the shortest path.',
        keywords: ['find a path (any)', 'check if path exists', 'connected components', 'cycles in a graph', 'count islands'],
        example: 'Given a matrix of 1s (land) and 0s (water), count the number of islands.'
    },
    'heap': {
        name: 'Priority Queue (Heap)',
        whenToUse: 'The problem asks to find or keep track of the "top K" elements (largest K or smallest K) from a collection of data.',
        keywords: ['k-th largest/smallest element', 'top k', 'median of a stream', 'schedule tasks'],
        example: 'Find the 10 most liked tweets from a real-time feed.'
    },
    'binary-search': {
        name: 'Binary Search',
        whenToUse: "The problem involves finding an item in a sorted array. More advanced, it can be used on optimization problems where you can \"guess\" an answer and check if it's valid, and the search space of answers is monotonic.",
        keywords: ['sorted array', 'find index of', 'the smallest/largest value X such that...'],
        example: 'Find the first number in a sorted array that is greater than or equal to Y.'
    }
  },
  challenges: [
    // Easy
    { problem: 'Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.', solution: 'binary-search', difficulty: 'Easy' },
    { problem: 'Given an array of integers `nums`, calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index\'s right.', solution: 'two-pointers', difficulty: 'Easy' },
    { problem: 'You are given a string `s`. The cost of deleting a single character is given. Return the minimum cost to make all characters in `s` unique.', solution: 'heap', difficulty: 'Easy' },
    { problem: 'Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.', solution: 'dfs', difficulty: 'Easy' },
    { problem: 'Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.', solution: 'sliding-window', difficulty: 'Easy' },
    { problem: 'Write a function to find the longest common prefix string amongst an array of strings.', solution: 'two-pointers', difficulty: 'Easy' },
    { problem: 'Given the `root` of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).', solution: 'dfs', difficulty: 'Easy' },
    { problem: 'You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?', solution: 'dynamic-programming', difficulty: 'Easy' },
    { problem: 'Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.', solution: 'two-pointers', difficulty: 'Easy' },
    { problem: 'Merge two sorted linked lists and return it as a new sorted list.', solution: 'two-pointers', difficulty: 'Easy' },
    { problem: 'Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.', solution: 'backtracking', difficulty: 'Easy' },
    { problem: 'Given an integer `n`, return `true` if it is a power of two. Otherwise, return `false`.', solution: 'binary-search', difficulty: 'Easy' },
    { problem: 'Reverse a singly linked list.', solution: 'two-pointers', difficulty: 'Easy' },
    { problem: 'Given the `root` of a binary tree, invert the tree, and return its root.', solution: 'dfs', difficulty: 'Easy' },
    { problem: 'Write a function that takes the binary representation of an unsigned integer and returns the number of \'1\' bits it has (also known as the Hamming weight).', solution: 'sliding-window', difficulty: 'Easy' },
    { problem: 'Given a string `s` consisting of words and spaces, return the length of the last word in the string.', solution: 'two-pointers', difficulty: 'Easy' },
    { problem: 'Given a binary tree, determine if it is a valid binary search tree (BST).', solution: 'dfs', difficulty: 'Easy' },
    { problem: 'Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.', solution: 'two-pointers', difficulty: 'Easy' },
    { problem: 'Given a string `s` containing just the characters `(`, `)`, `{`, `}`, `[` and `]`, determine if the input string is valid.', solution: 'backtracking', difficulty: 'Easy' },
    { problem: 'Implement a first in, first out (FIFO) queue using only two stacks.', solution: 'heap', difficulty: 'Easy' },
    { problem: 'Given a sorted array `nums`, remove the duplicates in-place such that each element appears only once and returns the new length.', solution: 'two-pointers', difficulty: 'Easy' },
    { problem: 'Given an integer `x`, return `true` if `x` is a palindrome, and `false` otherwise.', solution: 'two-pointers', difficulty: 'Easy' },
    { problem: 'Given the `root` of a binary tree, return the level order traversal of its nodes\' values. (i.e., from left to right, level by level).', solution: 'bfs', difficulty: 'Easy' },
    { problem: 'Given an array `nums`, write a function to move all 0\'s to the end of it while maintaining the relative order of the non-zero elements.', solution: 'two-pointers', difficulty: 'Easy' },
    { problem: 'Find the kth largest element in an unsorted array.', solution: 'heap', difficulty: 'Easy' },
    { problem: 'Given a string, find the first non-repeating character in it and return its index. If it does not exist, return -1.', solution: 'sliding-window', difficulty: 'Easy' },
    { problem: 'Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.', solution: 'dfs', difficulty: 'Easy' },
    { problem: 'You are given the heads of two sorted linked lists `list1` and `list2`. Merge the two lists into one sorted list.', solution: 'two-pointers', difficulty: 'Easy' },
    { problem: 'Given an array of `n` integers, where `n` > 1, `nums`, return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.', solution: 'dynamic-programming', difficulty: 'Easy' },
    { problem: 'Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.', solution: 'two-pointers', difficulty: 'Easy' },
    // Medium
    { problem: 'Given a string, find the length of the longest substring without repeating characters.', solution: 'sliding-window', difficulty: 'Medium' },
    { problem: 'Generate all valid combinations of parentheses for a given number of pairs.', solution: 'backtracking', difficulty: 'Medium' },
    { problem: 'Given a list of islands (represented by "1"s) and water (represented by "0"s), count the total number of distinct islands.', solution: 'dfs', difficulty: 'Medium' },
    { problem: 'You are on a 2D grid and need to find the shortest path from a starting point to an ending point, avoiding obstacles.', solution: 'bfs', difficulty: 'Medium' },
    { problem: 'Given an array of integers, find the subarray with the largest sum, and return its sum.', solution: 'dynamic-programming', difficulty: 'Medium' },
    { problem: 'Given an array of strings, group the anagrams together. You can return the answer in any order.', solution: 'sliding-window', difficulty: 'Medium' },
    { problem: 'Given a linked list, return the node where the cycle begins. If there is no cycle, return null.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Given an `m x n` 2D binary grid `grid` which represents a map of `1`s (land) and `0`s (water), return the number of islands.', solution: 'dfs', difficulty: 'Medium' },
    { problem: 'You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money. Return the fewest number of coins that you need to make up that amount.', solution: 'dynamic-programming', difficulty: 'Medium' },
    { problem: 'Given a string `s`, find the longest palindromic substring in `s`.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Given an array of `n` positive integers and a positive integer `s`, find the minimal length of a contiguous subarray of which the sum â‰¥ `s`. If there isn\'t one, return 0 instead.', solution: 'sliding-window', difficulty: 'Medium' },
    { problem: 'Given a set of distinct integers, `nums`, return all possible subsets (the power set).', solution: 'backtracking', difficulty: 'Medium' },
    { problem: 'Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.', solution: 'dfs', difficulty: 'Medium' },
    { problem: 'Given a 2D grid of characters and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where "adjacent" cells are horizontally or vertically neighboring.', solution: 'backtracking', difficulty: 'Medium' },
    { problem: 'Find the kth smallest element in a Binary Search Tree.', solution: 'heap', difficulty: 'Medium' },
    { problem: 'Given a binary tree, populate each `next` pointer to point to its next right node. If there is no next right node, the `next` pointer should be set to `NULL`.', solution: 'bfs', difficulty: 'Medium' },
    { problem: 'Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.', solution: 'backtracking', difficulty: 'Medium' },
    { problem: 'You are given an array of integers. A subsequence of this array is considered a valid mountain array if it is first increasing, then decreasing.', solution: 'dynamic-programming', difficulty: 'Medium' },
    { problem: 'Given an unsorted array of integers, find the length of the longest consecutive elements sequence.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.', solution: 'backtracking', difficulty: 'Medium' },
    { problem: 'Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.', solution: 'dfs', difficulty: 'Medium' },
    { problem: 'Given a sorted array of integers `nums` and an integer `target`, search for `target` in `nums`. If `target` exists, then return its index. Otherwise, return -1.', solution: 'binary-search', difficulty: 'Medium' },
    { problem: 'Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.', solution: 'backtracking', difficulty: 'Medium' },
    { problem: 'Given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words, determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.', solution: 'dynamic-programming', difficulty: 'Medium' },
    { problem: 'Given a linked list, rotate the list to the right by `k` places.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Given an array with `n` objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Given a `m x n` grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.', solution: 'dynamic-programming', difficulty: 'Medium' },
    { problem: 'You are given an `m x n` `grid` where `grid[i][j]` is either `0` (representing water) or `1` (representing land). An island is a group of `1`s connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value `1` in the island. Return the maximum area of an island in `grid`. If there is no island, return `0`.', solution: 'dfs', difficulty: 'Medium' },
    { problem: 'Given a list of non-negative integers representing the elevations of a map where the width of each bar is 1, compute how much water it can trap after raining.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Given a binary tree, return the zigzag level order traversal of its nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between).', solution: 'bfs', difficulty: 'Medium' },
    { problem: 'Given a string, determine if it is a valid palindrome, considering only alphanumeric characters and ignoring cases.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Given an array of integers where 1 â‰¤ a[i] â‰¤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Given a binary tree, return the right side view of it. (the nodes you can see from the right).', solution: 'bfs', difficulty: 'Medium' },
    { problem: 'Given a set of intervals, merge all overlapping intervals.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of `s`.', solution: 'backtracking', difficulty: 'Medium' },
    { problem: 'Design a data structure that supports adding new words and finding if a string matches any previously added string.', solution: 'dfs', difficulty: 'Medium' },
    { problem: 'Given a list of daily temperatures `T`, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.', solution: 'heap', difficulty: 'Medium' },
    { problem: 'Given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.', solution: 'sliding-window', difficulty: 'Medium' },
    { problem: 'A robot is located at the top-left corner of a `m x n` grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many possible unique paths are there?', solution: 'dynamic-programming', difficulty: 'Medium' },
    { problem: 'Given a `m x n` board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where "adjacent" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.', solution: 'backtracking', difficulty: 'Medium' },
    { problem: 'Given the root of a binary tree, determine if it is a valid binary search tree.', solution: 'dfs', difficulty: 'Medium' },
    { problem: 'Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.', solution: 'sliding-window', difficulty: 'Medium' },
    { problem: 'Given a list of words, please write a program that returns all concatenated words in the given list of words.', solution: 'dynamic-programming', difficulty: 'Medium' },
    { problem: 'Given a binary tree, serialize it to a string and deserialize it back to the tree.', solution: 'dfs', difficulty: 'Medium' },
    { problem: 'Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.', solution: 'backtracking', difficulty: 'Medium' },
    { problem: 'Given an array of `n` integers `nums`, are there elements `a`, `b`, `c` in `nums` such that `a + b + c = 0`? Find all unique triplets in the array which gives the sum of zero.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Search a 2D Matrix. Write an efficient algorithm that searches for a value in an `m x n` matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.', solution: 'binary-search', difficulty: 'Medium' },
    { problem: 'Given a linked list, remove the n-th node from the end of the list and return its head.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Given a collection of distinct integers, return all possible permutations.', solution: 'backtracking', difficulty: 'Medium' },
    { problem: 'Given a non-empty array of integers, return the `k` most frequent elements.', solution: 'heap', difficulty: 'Medium' },
    { problem: 'You are given a list of `jobs`. Each job has a `start time`, `end time`, and `profit`. Find the maximum profit you can make by scheduling the jobs such that no two jobs overlap.', solution: 'dynamic-programming', difficulty: 'Medium' },
    { problem: 'Find the median of two sorted arrays.', solution: 'binary-search', difficulty: 'Medium' },
    { problem: 'Given an array of integers, find the length of the longest increasing subsequence.', solution: 'dynamic-programming', difficulty: 'Medium' },
    { problem: 'Given `n`, generate all structurally unique BST\'s (binary search trees) that store values 1...n.', solution: 'dynamic-programming', difficulty: 'Medium' },
    { problem: 'Validate if a given string is a valid UTF-8 encoding.', solution: 'sliding-window', difficulty: 'Medium' },
    { problem: 'Clone a graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.', solution: 'bfs', difficulty: 'Medium' },
    { problem: 'Given a `m x n` matrix, if an element is 0, set its entire row and column to 0.', solution: 'two-pointers', difficulty: 'Medium' },
    { problem: 'Product of Array Except Self. Given an array `nums` of `n` integers where `n > 1`, return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.', solution: 'dynamic-programming', difficulty: 'Medium' },
    { problem: 'Course Schedule. There are a total of `n` courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]. Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?', solution: 'dfs', difficulty: 'Medium' },
    // Hard
    { problem: 'Given an array of non-negative integers representing the histogram\'s bar height where the width of each bar is 1, find the area of the largest rectangle in the histogram.', solution: 'two-pointers', difficulty: 'Hard' },
    { problem: 'Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, find the median of the two sorted arrays. The overall run time complexity should be O(log(m+n)).', solution: 'binary-search', difficulty: 'Hard' },
    { problem: 'Implement a regular expression matcher with support for `.` and `*`.', solution: 'dynamic-programming', difficulty: 'Hard' },
    { problem: 'Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.', solution: 'two-pointers', difficulty: 'Hard' },
    { problem: 'Merge `k` sorted linked lists and return it as one sorted list. Analyze and describe its complexity.', solution: 'heap', difficulty: 'Hard' },
    { problem: 'Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.', solution: 'backtracking', difficulty: 'Hard' },
    { problem: 'The N-Queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other. Given an integer `n`, return all distinct solutions to the N-Queens puzzle.', solution: 'backtracking', difficulty: 'Hard' },
    { problem: 'Given an array of integers, find the maximum sum of a subarray with the constraint that the subarray must be of size at least 1.', solution: 'dynamic-programming', difficulty: 'Hard' },
    { problem: 'There are two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively. Find the median of the two sorted arrays.', solution: 'binary-search', difficulty: 'Hard' },
    { problem: 'You are given a list of `points` representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`. The cost of connecting two points `(xi, yi)` and `(xj, yj)` is the manhattan distance between them: `|xi - xj| + |yi - yj|`. Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.', solution: 'dfs', difficulty: 'Hard' }
  ]
};
