export const pt = {
  sidebar: {
    title: 'PathFinder',
    theory: 'Teoria',
    algorithms: 'Algoritmos',
    challenges: 'Desafios',
    bigO: 'Nota√ß√£o Big O',
  },
  workspace: {
    selectAlgorithm: 'Selecione um algoritmo para ver os detalhes.',
  },
  bigO: {
    title: 'Entendendo a Nota√ß√£o Big O',
    description: 'A nota√ß√£o Big O √© como programadores falam sobre a efici√™ncia de algoritmos. Ela mede o pior caso de tempo ou espa√ßo que um algoritmo leva para ser conclu√≠do em rela√ß√£o ao tamanho de sua entrada (n). Em termos simples, descreve como o desempenho de um algoritmo escala √† medida que os dados de entrada crescem.',
    importanceTitle: 'Por que √© Importante?',
    importanceDescription: 'Conhecer o Big O ajuda voc√™ a escolher o algoritmo certo para o trabalho. Um algoritmo que funciona bem para uma entrada pequena pode se tornar inutilizavelmente lento com uma entrada grande. Entender o Big O ajuda a evitar gargalos de desempenho e a escrever c√≥digo mais r√°pido e escal√°vel.',
    complexities: {
      title: 'Complexidades Comuns',
      exampleLabel: 'Exemplo:',
      constant: {
        name: 'O(1) ‚Äî Tempo Constante',
        description: 'O algoritmo leva a mesma quantidade de tempo, independentemente do tamanho da entrada. Este √© o ideal.',
        example: 'Acessar um elemento em um array pelo seu √≠ndice (ex: `meu_array[5]`).',
      },
      logarithmic: {
        name: 'O(log n) ‚Äî Tempo Logar√≠tmico',
        description: 'O tempo que leva aumenta com o tamanho da entrada, mas o faz muito lentamente. Isso acontece quando o tamanho do problema √© reduzido pela metade a cada passo.',
        example: 'Busca Bin√°ria em um array ordenado.',
      },
      linear: {
        name: 'O(n) ‚Äî Tempo Linear',
        description: 'O tempo de execu√ß√£o √© diretamente proporcional ao tamanho da entrada (n). Se voc√™ dobrar a entrada, o tempo de execu√ß√£o dobra aproximadamente.',
        example: 'Iterar por todos os elementos de uma lista ou array.',
      },
      loglinear: {
        name: 'O(n log n) ‚Äî Tempo Log-Linear',
        description: 'Esta √© uma complexidade comum para algoritmos de ordena√ß√£o eficientes. √â um pouco mais lento que o linear, mas ainda muito perform√°tico para grandes conjuntos de dados.',
        example: 'Algoritmos de ordena√ß√£o eficientes como Merge Sort ou Quick Sort.',
      },
      quadratic: {
        name: 'O(n¬≤) ‚Äî Tempo Quadr√°tico',
        description: 'O tempo de execu√ß√£o √© proporcional ao quadrado do tamanho da entrada. Isso se torna lento muito rapidamente √† medida que n cresce.',
        example: 'Loops aninhados, onde voc√™ compara cada elemento de uma lista com todos os outros elementos (ex: encontrar todos os pares em uma lista).',
      },
      exponential: {
        name: 'O(2^n) ‚Äî Tempo Exponencial',
        description: 'O tempo de execu√ß√£o dobra para cada novo elemento no conjunto de entrada. Esses algoritmos s√£o extremamente lentos e pr√°ticos apenas para tamanhos de entrada muito pequenos.',
        example: 'Resolver problemas com solu√ß√µes recursivas de for√ßa bruta, como encontrar todos os subconjuntos de um conjunto (backtracking).',
      },
    },
  },
  algorithmDetails: {
    whenToUse: 'Quando Usar',
    keywords: 'Palavras-chave e Sinais',
    typicalProblem: 'Problema T√≠pico',
    codeTemplates: 'Modelos de C√≥digo',
    codeTemplatesDescription: 'Modelos b√°sicos em Python e JavaScript para voc√™ come√ßar.',
    bigO: 'Nota√ß√£o Big O',
    bigODescription: 'As caracter√≠sticas de desempenho deste algoritmo.',
    timeComplexity: 'Complexidade de Tempo',
    spaceComplexity: 'Complexidade de Espa√ßo',
    best: 'Melhor',
    average: 'M√©dio',
    worst: 'Pior',
    practiceThisAlgorithm: 'Praticar este algoritmo',
  },
  codeBlock: {
    copied: 'Copiado para a √°rea de transfer√™ncia!',
    copiedSuccess: 'O c√≥digo {language} foi copiado.',
    copyCode: 'Copiar c√≥digo',
  },
  challengeLabels: {
    title: 'Desafios de Algoritmo',
    learningTip: 'Para aprender ainda melhor, al√©m de praticar com os desafios de flashcard, √© bom anotar os exerc√≠cios, o algoritmo correto e construir a solu√ß√£o em um caderno para aprender e fixar o conhecimento.',
    nextChallenge: 'Pr√≥ximo Desafio',
    problem: 'Problema',
    whichAlgorithm: 'Qual algoritmo √© mais adequado?',
    checkAnswer: 'Verificar Resposta',
    selectOptionTitle: 'Selecione uma op√ß√£o',
    selectOptionDesc: 'Voc√™ precisa escolher um algoritmo antes de verificar a resposta.',
    correctTitle: 'Correto!',
    correctDesc: '√ìtimo trabalho!',
    incorrectTitle: 'Incorreto!',
    incorrectDesc: 'Tente novamente. Dica: Pense nas palavras-chave do problema.',
    correctExclamation: 'üéâ Correto! üéâ',
    correctSolution: 'O algoritmo correto √© {solution}. Bom trabalho!',
    incorrectExclamation: 'Quase l√°!',
    incorrectSolution: 'A resposta correta √© {solution}. N√£o se preocupe, continue tentando!',
    hint: 'Dica',
    tryAgain: 'Tentar Novamente',
    loading: 'Carregando desafios...',
    showingChallengesFor: 'Mostrando desafios para: {algorithm}',
    showingChallengesForDescription: 'Pratique com problemas espec√≠ficos para este algoritmo para domin√°-lo.',
    clearFilter: 'Limpar filtro e ver todos os desafios',
    noChallengesFound: 'Nenhum desafio encontrado para este filtro.',
  },
  algorithms: {
    'sliding-window': {
        name: 'Janela Deslizante',
        whenToUse: 'O problema envolve uma estrutura de dados linear (array, lista, string) e pede para encontrar uma subse√ß√£o cont√≠gua (subarray ou substring) que seja √≥tima de alguma forma (a mais longa, a mais curta, soma m√°xima, etc.).',
        keywords: ['subarray cont√≠guo', 'substring', 'comprimento mais longo/curto', 'soma m√°xima/m√≠nima', 'cont√©m k elementos distintos'],
        example: 'Dado um array de inteiros, encontre a soma m√°xima de qualquer subarray cont√≠guo de tamanho k.'
    },
    'two-pointers': {
        name: 'Dois Ponteiros',
        whenToUse: 'O problema envolve um array ordenado (ou que pode ser ordenado) e busca um par ou trio de elementos que satisfa√ßam uma condi√ß√£o. Frequentemente, um ponteiro come√ßa no in√≠cio e outro no final, movendo-se um em dire√ß√£o ao outro.',
        keywords: ['array ordenado', 'encontrar um par/trio', 'soma alvo', 'remover duplicatas', 'pal√≠ndromo'],
        example: 'Em um array ordenado, encontre dois n√∫meros que somam um valor alvo X.'
    },
    'backtracking': {
        name: 'Backtracking',
        whenToUse: 'O problema pede para encontrar todas as solu√ß√µes poss√≠veis ou uma √∫nica solu√ß√£o que satisfa√ßa restri√ß√µes complexas, construindo a resposta passo a passo. Se uma escolha leva a um beco sem sa√≠da, voc√™ "volta atr√°s" (backtrack) e tenta outra. √â uma Busca em Profundidade (DFS) estruturada.',
        keywords: ['encontrar todas as combina√ß√µes', 'permuta√ß√µes', 'subconjuntos', 'caminhos poss√≠veis', 'quebra-cabe√ßa', 'Sudoku', 'labirinto'],
        example: 'Dado um conjunto de n√∫meros, encontre todos os subconjuntos √∫nicos.'
    },
    'dynamic-programming': {
        name: 'Programa√ß√£o Din√¢mica (PD)',
        whenToUse: '√â um problema de otimiza√ß√£o (encontrar o m√°ximo/m√≠nimo) ou um problema de contagem (contar o n√∫mero de maneiras) onde a solu√ß√£o para um problema maior pode ser constru√≠da a partir das solu√ß√µes de subproblemas menores e sobrepostos.',
        keywords: ['n√∫mero de maneiras de...', 'caminho de custo m√≠nimo/m√°ximo', 'valor m√°ximo/m√≠nimo obten√≠vel', 'lucro m√°ximo'],
        example: 'Problema da Mochila: Dados itens com pesos e valores, qual √© o valor m√°ximo que pode caber em uma mochila de capacidade W?'
    },
    'bfs': {
        name: 'Busca em Largura (BFS)',
        whenToUse: 'O problema envolve grafos ou matrizes e pede o caminho mais curto de um ponto a outro, assumindo que todos os passos t√™m o mesmo custo. O BFS explora a vizinhan√ßa em "camadas".',
        keywords: ['caminho mais curto', 'menor n√∫mero de passos', 'n√≠veis de uma √°rvore', 'grafo n√£o ponderado', 'labirinto'],
        example: 'Em uma matriz com paredes, encontre o menor n√∫mero de passos para ir do canto superior esquerdo ao canto inferior direito.'
    },
    'dfs': {
        name: 'Busca em Profundidade (DFS)',
        whenToUse: 'O problema envolve grafos ou matrizes e pede para explorar caminhos at√© o fim, verificar se um caminho existe ou encontrar componentes conectados. N√£o garante o caminho mais curto.',
        keywords: ['encontrar um caminho (qualquer)', 'verificar se o caminho existe', 'componentes conectados', 'ciclos em um grafo', 'contar ilhas'],
        example: 'Dada uma matriz de 1s (terra) e 0s (√°gua), conte o n√∫mero de ilhas.'
    },
    'heap': {
        name: 'Fila de Prioridade (Heap)',
        whenToUse: 'O problema pede para encontrar ou manter o controle dos "top K" elementos (K maiores ou K menores) de uma cole√ß√£o de dados.',
        keywords: ['k-√©simo maior/menor elemento', 'top k', 'mediana de um fluxo', 'agendar tarefas'],
        example: 'Encontre os 10 tweets mais curtidos de um feed em tempo real.'
    },
    'binary-search': {
        name: 'Busca Bin√°ria',
        whenToUse: 'O problema envolve encontrar um item em um array ordenado. De forma mais avan√ßada, pode ser usado em problemas de otimiza√ß√£o onde voc√™ pode "adivinhar" uma resposta e verificar se √© v√°lida, e o espa√ßo de busca das respostas √© monot√¥nico.',
        keywords: ['array ordenado', 'encontrar √≠ndice de', 'o menor/maior valor X tal que...'],
        example: 'Encontre o primeiro n√∫mero em um array ordenado que seja maior ou equal a Y.'
    }
  },
  challenges: [
    // F√°cil
    { problem: 'Dado um array ordenado de inteiros distintos e um valor alvo, retorne o √≠ndice se o alvo for encontrado. Se n√£o, retorne o √≠ndice onde ele estaria se fosse inserido em ordem.', solution: 'binary-search', difficulty: 'F√°cil' },
    { problem: 'Dado um array de inteiros `nums`, calcule o √≠ndice piv√¥ deste array. O √≠ndice piv√¥ √© o √≠ndice onde a soma de todos os n√∫meros estritamente √† esquerda do √≠ndice √© igual √† soma de todos os n√∫meros estritamente √† direita do √≠ndice.', solution: 'two-pointers', difficulty: 'F√°cil' },
    { problem: 'Voc√™ recebe uma string `s`. O custo de deletar um √∫nico caractere √© dado. Retorne o custo m√≠nimo para tornar todos os caracteres em `s` √∫nicos.', solution: 'heap', difficulty: 'F√°cil' },
    { problem: 'Dada uma √°rvore bin√°ria, encontre sua profundidade m√°xima. A profundidade m√°xima √© o n√∫mero de n√≥s ao longo do caminho mais longo do n√≥ raiz at√© a folha mais distante.', solution: 'dfs', difficulty: 'F√°cil' },
    { problem: 'Dadas duas strings `s` e `t`, retorne `true` se `t` for um anagrama de `s`, e `false` caso contr√°rio.', solution: 'sliding-window', difficulty: 'F√°cil' },
    { problem: 'Escreva uma fun√ß√£o para encontrar o prefixo comum mais longo entre um array de strings.', solution: 'two-pointers', difficulty: 'F√°cil' },
    { problem: 'Dada a `root` de uma √°rvore bin√°ria, verifique se ela √© um espelho de si mesma (ou seja, sim√©trica em rela√ß√£o ao seu centro).', solution: 'dfs', difficulty: 'F√°cil' },
    { problem: 'Voc√™ est√° subindo uma escada. Leva `n` degraus para chegar ao topo. Cada vez voc√™ pode subir 1 ou 2 degraus. De quantas maneiras distintas voc√™ pode subir at√© o topo?', solution: 'dynamic-programming', difficulty: 'F√°cil' },
    { problem: 'Dado um array de inteiros `nums`, retorne `true` se qualquer valor aparecer pelo menos duas vezes no array, e retorne `false` se cada elemento for distinto.', solution: 'two-pointers', difficulty: 'F√°cil' },
    { problem: 'Mescle duas listas ligadas ordenadas e retorne-a como uma nova lista ordenada.', solution: 'two-pointers', difficulty: 'F√°cil' },
    { problem: 'Dado um array n√£o vazio de inteiros `nums`, cada elemento aparece duas vezes, exceto um. Encontre esse √∫nico.', solution: 'backtracking', difficulty: 'F√°cil' },
    { problem: 'Dado um inteiro `n`, retorne `true` se for uma pot√™ncia de dois. Caso contr√°rio, retorne `false`.', solution: 'binary-search', difficulty: 'F√°cil' },
    { problem: 'Reverta uma lista ligada individualmente.', solution: 'two-pointers', difficulty: 'F√°cil' },
    { problem: 'Dada a `root` de uma √°rvore bin√°ria, inverta a √°rvore e retorne sua raiz.', solution: 'dfs', difficulty: 'F√°cil' },
    { problem: 'Escreva uma fun√ß√£o que receba a representa√ß√£o bin√°ria de um inteiro sem sinal e retorne o n√∫mero de bits \'1\' que ele possui (tamb√©m conhecido como peso de Hamming).', solution: 'sliding-window', difficulty: 'F√°cil' },
    { problem: 'Dada uma string `s` que consiste em palavras e espa√ßos, retorne o comprimento da √∫ltima palavra na string.', solution: 'two-pointers', difficulty: 'F√°cil' },
    { problem: 'Dada uma √°rvore bin√°ria, determine se ela √© uma √°rvore de busca bin√°ria (BST) v√°lida.', solution: 'dfs', difficulty: 'F√°cil' },
    { problem: 'Dado um array de inteiros `nums` e um inteiro `target`, retorne os √≠ndices dos dois n√∫meros que somam `target`.', solution: 'two-pointers', difficulty: 'F√°cil' },
    { problem: 'Dada uma string `s` contendo apenas os caracteres `(`, `)`, `{`, `}`, `[` e `]`, determine se a string de entrada √© v√°lida.', solution: 'backtracking', difficulty: 'F√°cil' },
    { problem: 'Implemente uma fila primeiro a entrar, primeiro a sair (FIFO) usando apenas duas pilhas.', solution: 'heap', difficulty: 'F√°cil' },
    { problem: 'Dado um array ordenado `nums`, remova as duplicatas no local de modo que cada elemento apare√ßa apenas uma vez e retorne o novo comprimento.', solution: 'two-pointers', difficulty: 'F√°cil' },
    { problem: 'Dado um inteiro `x`, retorne `true` se `x` for um pal√≠ndromo, e `false` caso contr√°rio.', solution: 'two-pointers', difficulty: 'F√°cil' },
    { problem: 'Dada a `root` de uma √°rvore bin√°ria, retorne a travessia em ordem de n√≠vel de seus n√≥s\' valores. (ou seja, da esquerda para a direita, n√≠vel por n√≠vel).', solution: 'bfs', difficulty: 'F√°cil' },
    { problem: 'Dado um array `nums`, escreva uma fun√ß√£o para mover todos os 0s para o final, mantendo a ordem relativa dos elementos n√£o-zero.', solution: 'two-pointers', difficulty: 'F√°cil' },
    { problem: 'Encontre o k-√©simo maior elemento em um array n√£o ordenado.', solution: 'heap', difficulty: 'F√°cil' },
    { problem: 'Dada uma string, encontre o primeiro caractere n√£o repetido nela e retorne seu √≠ndice. Se n√£o existir, retorne -1.', solution: 'sliding-window', difficulty: 'F√°cil' },
    { problem: 'Dada uma √°rvore bin√°ria e uma soma, determine se a √°rvore tem um caminho da raiz √† folha tal que a soma de todos os valores ao longo do caminho seja igual √† soma dada.', solution: 'dfs', difficulty: 'F√°cil' },
    { problem: 'Voc√™ recebe as cabe√ßas de duas listas ligadas ordenadas `list1` e `list2`. Mescle as duas listas em uma lista ordenada.', solution: 'two-pointers', difficulty: 'F√°cil' },
    { problem: 'Dado um array de `n` inteiros, onde `n` > 1, `nums`, retorne um array `output` tal que `output[i]` seja igual ao produto de todos os elementos de `nums` exceto `nums[i]`.', solution: 'dynamic-programming', difficulty: 'F√°cil' },
    { problem: 'Determine se um inteiro √© um pal√≠ndromo. Um inteiro √© um pal√≠ndromo quando l√™ o mesmo de tr√°s para frente.', solution: 'two-pointers', difficulty: 'F√°cil' },
    // M√©dio
    { problem: 'Dada uma string, encontre o comprimento da substring mais longa sem caracteres repetidos.', solution: 'sliding-window', difficulty: 'M√©dio' },
    { problem: 'Gere todas as combina√ß√µes v√°lidas de par√™nteses para um dado n√∫mero de pares.', solution: 'backtracking', difficulty: 'M√©dio' },
    { problem: 'Dada uma lista de ilhas (representadas por "1"s) e √°gua (representada por "0"s), conte o n√∫mero total de ilhas distintas.', solution: 'dfs', difficulty: 'M√©dio' },
    { problem: 'Voc√™ est√° em uma grade 2D e precisa encontrar o caminho mais curto de um ponto de partida a um ponto de chegada, evitando obst√°culos.', solution: 'bfs', difficulty: 'M√©dio' },
    { problem: 'Dado um array de inteiros, encontre o subarray com a maior soma e retorne sua soma.', solution: 'dynamic-programming', difficulty: 'M√©dio' },
    { problem: 'Dado um array de strings, agrupe os anagramas. Voc√™ pode retornar a resposta em qualquer ordem.', solution: 'sliding-window', difficulty: 'M√©dio' },
    { problem: 'Dada uma lista ligada, retorne o n√≥ onde o ciclo come√ßa. Se n√£o houver ciclo, retorne nulo.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Dado um grid bin√°rio `m x n` `grid` que representa um mapa de `1`s (terra) e `0`s (√°gua), retorne o n√∫mero de ilhas.', solution: 'dfs', difficulty: 'M√©dio' },
    { problem: 'Voc√™ recebe um array de inteiros `coins` representando moedas de diferentes denomina√ß√µes e um inteiro `amount` representando uma quantia total de dinheiro. Retorne o menor n√∫mero de moedas que voc√™ precisa para compor essa quantia.', solution: 'dynamic-programming', difficulty: 'M√©dio' },
    { problem: 'Dada uma string `s`, encontre a substring pal√≠ndroma mais longa em `s`.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Dado um array de `n` inteiros positivos e um inteiro positivo `s`, encontre o comprimento m√≠nimo de um subarray cont√≠guo cuja soma seja ‚â• `s`. Se n√£o houver, retorne 0.', solution: 'sliding-window', difficulty: 'M√©dio' },
    { problem: 'Dado um conjunto de inteiros distintos, `nums`, retorne todos os subconjuntos poss√≠veis (o conjunto de pot√™ncia).', solution: 'backtracking', difficulty: 'M√©dio' },
    { problem: 'Implemente um iterador sobre uma √°rvore de busca bin√°ria (BST). Seu iterador ser√° inicializado com o n√≥ raiz de uma BST.', solution: 'dfs', difficulty: 'M√©dio' },
    { problem: 'Dada uma grade 2D de caracteres e uma palavra, encontre se a palavra existe na grade. A palavra pode ser constru√≠da a partir de letras de c√©lulas sequencialmente adjacentes, onde c√©lulas "adjacentes" s√£o vizinhas horizontal ou verticalmente.', solution: 'backtracking', difficulty: 'M√©dio' },
    { problem: 'Encontre o k-√©simo menor elemento em uma √Årvore de Busca Bin√°ria.', solution: 'heap', difficulty: 'M√©dio' },
    { problem: 'Dada uma √°rvore bin√°ria, preencha cada ponteiro `next` para apontar para o seu pr√≥ximo n√≥ √† direita. Se n√£o houver pr√≥ximo n√≥ √† direita, o ponteiro `next` deve ser definido como `NULL`.', solution: 'bfs', difficulty: 'M√©dio' },
    { problem: 'Dada uma string contendo d√≠gitos de 2 a 9 inclusive, retorne todas as combina√ß√µes de letras poss√≠veis que o n√∫mero poderia representar.', solution: 'backtracking', difficulty: 'M√©dio' },
    { problem: 'Voc√™ recebe um array de inteiros. Uma subsequ√™ncia deste array √© considerada uma matriz de montanha v√°lida se for primeiro crescente e depois decrescente.', solution: 'dynamic-programming', difficulty: 'M√©dio' },
    { problem: 'Dado um array n√£o ordenado de inteiros, encontre o comprimento da sequ√™ncia de elementos consecutivos mais longa.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Dado `n` pares de par√™nteses, escreva uma fun√ß√£o para gerar todas as combina√ß√µes de par√™nteses bem formados.', solution: 'backtracking', difficulty: 'M√©dio' },
    { problem: 'Dada uma √°rvore bin√°ria, encontre o ancestral comum mais baixo (LCA) de dois n√≥s dados na √°rvore.', solution: 'dfs', difficulty: 'M√©dio' },
    { problem: 'Dado um array ordenado de inteiros `nums` e um inteiro `target`, procure `target` em `nums`. Se `target` existir, retorne seu √≠ndice. Caso contr√°rio, retorne -1.', solution: 'binary-search', difficulty: 'M√©dio' },
    { problem: 'Dada uma cole√ß√£o de n√∫meros candidatos (`candidates`) e um n√∫mero alvo (`target`), encontre todas as combina√ß√µes √∫nicas em `candidates` onde a soma dos n√∫meros candidatos seja `target`.', solution: 'backtracking', difficulty: 'M√©dio' },
    { problem: 'Dada uma string n√£o vazia `s` e um dicion√°rio `wordDict` contendo uma lista de palavras n√£o vazias, determine se `s` pode ser segmentado em uma sequ√™ncia de uma ou mais palavras do dicion√°rio separadas por espa√ßo.', solution: 'dynamic-programming', difficulty: 'M√©dio' },
    { problem: 'Dada uma lista ligada, rotacione a lista para a direita em `k` lugares.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Dado um array com `n` objetos coloridos de vermelho, branco ou azul, ordene-os no local para que objetos da mesma cor fiquem adjacentes, com as cores na ordem vermelho, branco e azul.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Dada uma grade `m x n` preenchida com n√∫meros n√£o negativos, encontre um caminho do canto superior esquerdo ao canto inferior direito, que minimize a soma de todos os n√∫meros ao longo de seu caminho.', solution: 'dynamic-programming', difficulty: 'M√©dio' },
    { problem: 'Voc√™ recebe uma `grid` `m x n` onde `grid[i][j]` √© `0` (representando √°gua) ou `1` (representando terra). Uma ilha √© um grupo de `1`s conectado 4-direcionalmente (horizontal ou vertical). Voc√™ pode assumir que todas as quatro bordas da grade est√£o cercadas por √°gua. A √°rea de uma ilha √© o n√∫mero de c√©lulas com valor `1` na ilha. Retorne a √°rea m√°xima de uma ilha em `grid`. Se n√£o houver ilha, retorne `0`.', solution: 'dfs', difficulty: 'M√©dio' },
    { problem: 'Dada uma lista de inteiros n√£o negativos representando as eleva√ß√µes de um mapa onde a largura de cada barra √© 1, calcule quanta √°gua ele pode reter ap√≥s a chuva.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Dada uma √°rvore bin√°ria, retorne a travessia em ziguezague de ordem de n√≠vel de seus n√≥s\' valores. (ou seja, da esquerda para a direita, depois da direita para a esquerda para o pr√≥ximo n√≠vel e alternar).', solution: 'bfs', difficulty: 'M√©dio' },
    { problem: 'Dada uma string, determine se ela √© um pal√≠ndromo v√°lido, considerando apenas caracteres alfanum√©ricos e ignorando mai√∫sculas e min√∫sculas.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Dado um array de inteiros where 1 ‚â§ a[i] ‚â§ n (n = tamanho do array), alguns elementos aparecem duas vezes e outros uma vez. Encontre todos os elementos de [1, n] inclusive que n√£o aparecem neste array.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Dada uma √°rvore bin√°ria, retorne a vis√£o do lado direito dela. (os n√≥s que voc√™ pode ver do lado direito).', solution: 'bfs', difficulty: 'M√©dio' },
    { problem: 'Dado um conjunto de intervalos, mescle todos os intervalos sobrepostos.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Dada uma string `s`, particione `s` de modo que cada substring da parti√ß√£o seja um pal√≠ndromo. Retorne todas as parti√ß√µes pal√≠ndromas poss√≠veis de `s`.', solution: 'backtracking', difficulty: 'M√©dio' },
    { problem: 'Projete uma estrutura de dados que suporte adicionar novas palavras e encontrar se uma string corresponde a qualquer string adicionada anteriormente.', solution: 'dfs', difficulty: 'M√©dio' },
    { problem: 'Dada uma lista de temperaturas di√°rias `T`, retorne uma lista tal que, para cada dia na entrada, diga quantos dias voc√™ teria que esperar at√© uma temperatura mais quente. Se n√£o houver um dia futuro para o qual isso seja poss√≠vel, coloque 0 em vez disso.', solution: 'heap', difficulty: 'M√©dio' },
    { problem: 'Dado um array de inteiros `nums`, h√° uma janela deslizante de tamanho `k` que est√° se movendo da extrema esquerda do array para a extrema direita. Voc√™ s√≥ pode ver os `k` n√∫meros na janela. Cada vez que a janela deslizante se move para a direita em uma posi√ß√£o. Retorne a janela deslizante m√°xima.', solution: 'sliding-window', difficulty: 'M√©dio' },
    { problem: 'Um rob√¥ est√° localizado no canto superior esquerdo de uma grade `m x n`. O rob√¥ s√≥ pode se mover para baixo ou para a direita em qualquer ponto no tempo. O rob√¥ est√° tentando chegar ao canto inferior direito da grade. Quantos caminhos √∫nicos poss√≠veis existem?', solution: 'dynamic-programming', difficulty: 'M√©dio' },
    { problem: 'Dado um tabuleiro `m x n` e uma palavra, encontre se a palavra existe na grade. A palavra pode ser constru√≠da a partir de letras de c√©lulas sequencialmente adjacentes, onde c√©lulas "adjacentes" s√£o vizinhas horizontal ou verticalmente. A mesma c√©lula de letra n√£o pode ser usada mais de uma vez.', solution: 'backtracking', difficulty: 'M√©dio' },
    { problem: 'Dada a raiz de uma √°rvore bin√°ria, determine se ela √© uma √°rvore de busca bin√°ria v√°lida.', solution: 'dfs', difficulty: 'M√©dio' },
    { problem: 'Dado um fluxo de inteiros e um tamanho de janela, calcule a m√©dia m√≥vel de todos os inteiros na janela deslizante.', solution: 'sliding-window', difficulty: 'M√©dio' },
    { problem: 'Dada uma lista de palavras, escreva um programa que retorne todas as palavras concatenadas na lista de palavras dada.', solution: 'dynamic-programming', difficulty: 'M√©dio' },
    { problem: 'Dada uma √°rvore bin√°ria, serialize-a para uma string e desserialize-a de volta para a √°rvore.', solution: 'dfs', difficulty: 'M√©dio' },
    { problem: 'Dado um array de inteiros com todos os n√∫meros positivos e sem duplicatas, encontre o n√∫mero de combina√ß√µes poss√≠veis que somam um alvo inteiro positivo.', solution: 'backtracking', difficulty: 'M√©dio' },
    { problem: 'Dado um array de `n` inteiros `nums`, existem elementos `a`, `b`, `c` em `nums` tais que `a + b + c = 0`? Encontre todos os trios √∫nicos no array que d√£o a soma de zero.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Pesquisar uma Matriz 2D. Escreva um algoritmo eficiente que procura um valor em uma matriz `m x n`. Esta matriz tem as seguintes propriedades: Os inteiros em cada linha s√£o ordenados da esquerda para a direita. O primeiro inteiro de cada linha √© maior que o √∫ltimo inteiro da linha anterior.', solution: 'binary-search', difficulty: 'M√©dio' },
    { problem: 'Dada uma lista ligada, remova o n-√©simo n√≥ do final da lista e retorne sua cabe√ßa.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Dada uma cole√ß√£o de inteiros distintos, retorne todas as permuta√ß√µes poss√≠veis.', solution: 'backtracking', difficulty: 'M√©dio' },
    { problem: 'Dado um array n√£o vazio de inteiros, retorne os `k` elementos mais frequentes.', solution: 'heap', difficulty: 'M√©dio' },
    { problem: 'Voc√™ recebe uma lista de `jobs`. Cada trabalho tem um `start time`, `end time` e `profit`. Encontre o lucro m√°ximo que voc√™ pode obter agendando os trabalhos de forma que n√£o haja sobreposi√ß√£o de dois trabalhos.', solution: 'dynamic-programming', difficulty: 'M√©dio' },
    { problem: 'Encontre a mediana de dois arrays ordenados.', solution: 'binary-search', difficulty: 'M√©dio' },
    { problem: 'Dado um array de inteiros, encontre o comprimento da subsequ√™ncia crescente mais longa.', solution: 'dynamic-programming', difficulty: 'M√©dio' },
    { problem: 'Dado `n`, gere todas as BSTs (√°rvores de busca bin√°ria) estruturalmente √∫nicas que armazenam valores 1...n.', solution: 'dynamic-programming', difficulty: 'M√©dio' },
    { problem: 'Valide se uma determinada string √© uma codifica√ß√£o UTF-8 v√°lida.', solution: 'sliding-window', difficulty: 'M√©dio' },
    { problem: 'Clone um gr√°fico. Cada n√≥ no gr√°fico cont√©m um val (int) e uma lista (List[Node]) de seus vizinhos.', solution: 'bfs', difficulty: 'M√©dio' },
    { problem: 'Dada uma matriz `m x n`, se um elemento for 0, defina toda a sua linha e coluna como 0.', solution: 'two-pointers', difficulty: 'M√©dio' },
    { problem: 'Produto do Array Exceto Ele Mesmo. Dado um array `nums` de `n` inteiros onde `n > 1`, retorne um array `output` tal que `output[i]` seja igual ao produto de todos os elementos de `nums` exceto `nums[i]`.', solution: 'dynamic-programming', difficulty: 'M√©dio' },
    { problem: 'Grade Curricular. H√° um total de `n` cursos que voc√™ precisa fazer, rotulados de 0 a n-1. Alguns cursos podem ter pr√©-requisitos, por exemplo, para fazer o curso 0, voc√™ precisa primeiro fazer o curso 1, o que √© expresso como um par: [0,1]. Dado o n√∫mero total de cursos e uma lista de pares de pr√©-requisitos, √© poss√≠vel para voc√™ terminar todos os cursos?', solution: 'dfs', difficulty: 'M√©dio' },
    // Dif√≠cil
    { problem: 'Dado um array de inteiros n√£o negativos representando a altura da barra do histograma onde a largura de cada barra √© 1, encontre a √°rea do maior ret√¢ngulo no histograma.', solution: 'two-pointers', difficulty: 'Dif√≠cil' },
    { problem: 'Dadas duas matrizes ordenadas `nums1` e `nums2` de tamanhos `m` e `n`, respectivamente, encontre a mediana das duas matrizes ordenadas. A complexidade de tempo de execu√ß√£o geral deve ser O(log(m+n)).', solution: 'binary-search', difficulty: 'Dif√≠cil' },
    { problem: 'Implemente um matcher de express√£o regular com suporte para `.` e `*`.', solution: 'dynamic-programming', difficulty: 'Dif√≠cil' },
    { problem: 'Dado `n` inteiros n√£o negativos representando um mapa de eleva√ß√£o onde a largura de cada barra √© 1, calcule quanta √°gua ele pode reter ap√≥s chover.', solution: 'two-pointers', difficulty: 'Dif√≠cil' },
    { problem: 'Mescle `k` listas ligadas ordenadas e retorne-a como uma lista ordenada. Analise e descreva sua complexidade.', solution: 'heap', difficulty: 'Dif√≠cil' },
    { problem: 'Dada uma string `s` e um dicion√°rio de strings `wordDict`, adicione espa√ßos em `s` para construir uma frase onde cada palavra √© uma palavra v√°lida do dicion√°rio. Retorne todas as frases poss√≠veis.', solution: 'backtracking', difficulty: 'Dif√≠cil' },
    { problem: 'O quebra-cabe√ßa das N-Rainhas √© o problema de colocar `n` rainhas em um tabuleiro de xadrez `n x n` de modo que duas rainhas n√£o se ataquem. Dado um inteiro `n`, retorne todas as solu√ß√µes distintas para o quebra-cabe√ßa das N-Rainhas.', solution: 'backtracking', difficulty: 'Dif√≠cil' },
    { problem: 'Dado um array de inteiros, encontre a soma m√°xima de um subarray com a restri√ß√£o de que o subarray deve ter tamanho de pelo menos 1.', solution: 'dynamic-programming', difficulty: 'Dif√≠cil' },
    { problem: 'Existem dois arrays ordenados `nums1` e `nums2` de tamanhos `m` e `n`, respectivamente. Encontre a mediana dos dois arrays ordenados.', solution: 'binary-search', difficulty: 'Dif√≠cil' },
    { problem: 'Voc√™ recebe uma lista de `points` representando coordenadas inteiras de alguns pontos em um plano 2D, onde `points[i] = [xi, yi]`. O custo de conectar dois pontos `(xi, yi)` e `(xj, yj)` √© a dist√¢ncia de Manhattan entre eles: `|xi - xj| + |yi - yj|`. Retorne o custo m√≠nimo para conectar todos os pontos. Todos os pontos est√£o conectados se houver exatamente um caminho simples entre quaisquer dois pontos.', solution: 'dfs', difficulty: 'Dif√≠cil' }
  ]
};
